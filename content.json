{"meta":{"title":"Five","subtitle":"Enjoy Code","description":"我挥舞着键盘和本子，发誓要把世界写个明明白白","author":"嘉晨","url":"https://markfrank01.github.io"},"pages":[{"title":"","date":"2017-04-09T04:12:10.646Z","updated":"2017-04-09T04:12:10.646Z","comments":true,"path":"sw.js","permalink":"https://markfrank01.github.io/sw.js","excerpt":"","text":"'use strict'; const version = 'v20170405'; const __DEVELOPMENT__ = false; const __DEBUG__ = false; const offlineResources = [ '/', '/offline.html', '/offline.svg' ]; const matchFetch = [ /https?:\\/\\/huaji8.top\\// ]; ////////// // Install ////////// function onInstall(event) { log('install event in progress.'); event.waitUntil(updateStaticCache()); } function updateStaticCache() { return caches .open(cacheKey('offline')) .then((cache) => { return cache.addAll(offlineResources); }) .then(() => { log('installation complete!'); }); } //////// // Fetch //////// function onFetch(event) { const request = event.request; if (shouldAlwaysFetch(request)) { event.respondWith(networkedOrOffline(request)); return; } if (shouldFetchAndCache(request)) { event.respondWith(networkedOrCached(request)); return; } event.respondWith(cachedOrNetworked(request)); } function networkedOrCached(request) { return networkedAndCache(request) .catch(() => { return cachedOrOffline(request) }); } // Stash response in cache as side-effect of network request function networkedAndCache(request) { return fetch(request) .then((response) => { var copy = response.clone(); caches.open(cacheKey('resources')) .then((cache) => { cache.put(request, copy); }); log(\"(network: cache write)\", request.method, request.url); return response; }); } function cachedOrNetworked(request) { return caches.match(request) .then((response) => { log(response ? '(cached)' : '(network: cache miss)', request.method, request.url); return response || networkedAndCache(request) .catch(() => { return offlineResponse(request) }); }); } function networkedOrOffline(request) { return fetch(request) .then((response) => { log('(network)', request.method, request.url); return response; }) .catch(() => { return offlineResponse(request); }); } function cachedOrOffline(request) { return caches .match(request) .then((response) => { return response || offlineResponse(request); }); } function offlineResponse(request) { log('(offline)', request.method, request.url); if (request.url.match(/\\.(jpg|png|gif|svg|jpeg)(\\?.*)?$/)) { return caches.match('/offline.svg'); } else { return caches.match('/offline.html'); } } /////////// // Activate /////////// function onActivate(event) { log('activate event in progress.'); event.waitUntil(removeOldCache()); } function removeOldCache() { return caches .keys() .then((keys) => { return Promise.all( // We return a promise that settles when all outdated caches are deleted. keys .filter((key) => { return !key.startsWith(version); // Filter by keys that don't start with the latest version prefix. }) .map((key) => { return caches.delete(key); // Return a promise that's fulfilled when each outdated cache is deleted. }) ); }) .then(() => { log('removeOldCache completed.'); }); } function cacheKey() { return [version, ...arguments].join(':'); } function log() { if (developmentMode()) { console.log(\"SW:\", ...arguments); } } function shouldAlwaysFetch(request) { return __DEVELOPMENT__ || request.method !== 'GET' || !matchFetch.some(regex => request.url.match(regex)); } function shouldFetchAndCache(request) { return ~request.headers.get('Accept').indexOf('text/html'); } function developmentMode() { return __DEVELOPMENT__ || __DEBUG__; } log(\"Hello from ServiceWorker land!\", version); self.addEventListener('install', onInstall); self.addEventListener('fetch', onFetch); self.addEventListener(\"activate\", onActivate);"},{"title":"关于我","date":"2017-01-14T08:58:59.000Z","updated":"2017-04-09T04:12:10.647Z","comments":true,"path":"关于我.html","permalink":"https://markfrank01.github.io/关于我.html","excerpt":"","text":"拼命想抓住一些东西！前端 程序员 主攻web node全栈 喜欢 编程，游戏，绘画，音乐，动漫 QQ：1106996185 steam： 滑稽(╬▔皿▔) 网易云音乐: CNEYHN github: EYHN 网易云: CNEYHN 如果你喜欢这个主题，请到主题的github点个star，这是对我最大的支持! 封面画师: saberiii"},{"title":"关于本站","date":"2017-04-04T11:05:00.000Z","updated":"2017-04-09T04:12:10.647Z","comments":true,"path":"关于本站.html","permalink":"https://markfrank01.github.io/关于本站.html","excerpt":"","text":"我希望它成为一个以技术帖为主的博客。 友情链接: Halyul 「Never do a dreamer.」Mo Curio 「一个高中生的心事」 我喜欢的 blog : 阮一峰的网络日志前端新技术，新趋势，新知识。博主注重程序设计这点和我很像。 我思空間 「一個對動漫、電影、遊戲、小說以及各種命題作出探討的地方。」博主文笔好，喜欢长篇大论，看的爽啊。 封面画师: saberiii"},{"title":"categories","date":"2017-09-25T05:22:12.000Z","updated":"2017-09-25T05:22:55.710Z","comments":false,"path":"categories/index.html","permalink":"https://markfrank01.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-09T04:53:04.992Z","updated":"2017-04-09T04:12:10.491Z","comments":true,"path":"head/piwik.html","permalink":"https://markfrank01.github.io/head/piwik.html","excerpt":"","text":"var _paq = _paq || []; /* tracker methods like \"setCustomDimension\" should be called before \"trackPageView\" */ _paq.push(['trackPageView']); _paq.push(['enableLinkTracking']); (function() { var u=\"//piwik.huaji8.top/\"; _paq.push(['setTrackerUrl', u+'piwik.php']); _paq.push(['setSiteId', '1']); var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0]; g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s); })();"},{"title":"","date":"2017-04-09T04:53:12.783Z","updated":"2017-04-09T04:12:10.491Z","comments":true,"path":"head/serviceWorker.html","permalink":"https://markfrank01.github.io/head/serviceWorker.html","excerpt":"","text":"if ('serviceWorker' in navigator) { window.addEventListener('load', function () { navigator.serviceWorker.register('/sw.js').then(function (registration) { // Registration was successful console.log('ServiceWorker registration successful with scope: ', registration.scope); }).catch(function (err) { // registration failed :( console.log('ServiceWorker registration failed: ', err); }); }); }"},{"title":"四大组件之Activity","date":"2018-01-01T14:15:32.000Z","updated":"2018-04-16T07:10:02.233Z","comments":true,"path":"不想提交TAT/Activity.html","permalink":"https://markfrank01.github.io/不想提交TAT/Activity.html","excerpt":"Activity的回顾","text":"Activity的回顾 引言 开启一个新的系列目的一是为了整理和巩固基础的知识，3月底要进军企鹅，二是为了给后来者留下一个肩膀，我也曾经历过找不到好的资料的苦恼，希望现在我可以写出更好的文章，整理出更好的内容，分享给大家 这个系列我把它定义为进阶之路，需要有一定的知识进行积累。也将它直指面试。通过面对问题的思考带出知识的运用和理解。所以每篇文章将持续更新！ 问题思考： 一、Android的生命周期 二、Android的启动模式 三、IntentFilter的匹配规则 一、Activity的生命周期全面分析分为两部分，一是典型情况下的生命周期，另一部分是异常情况下的生命周期 典型情况下的生命周期分析 通过此图附加说明一下几种不同的情况: （1）针对一个特定的Activity,第一次启动。回调如下：onCreat - &gt; onStart - &gt; onResume （2）当用户打开新的Activity或者切换到桌面的时候。回调如下：onPause - &gt; onStop。特殊情况如果Activity采用了透明的主题，则不会发生OnStop回调 （3）当用户再次回到原Activity时，回调如下：onRestart - &gt; onStart - &gt; onResume （4）当用户按back键返回时，回调如下：onPause-&gt; onStop - &gt; onDestory （5）当Activity被系统回收后再次打开，生命周期和（1）一样，但不是所有过程都一样 异常情况下的生命周期分析 1.资源相关的系统配置发生改变导致Activity被杀死并重新创建 异常情况下Activity的重建过程 2.资源内存不足导致低优先级的Activity被杀死 简单描述一下优先级 前台Activity——正在和用户交互的Activity，优先级最高。 可见但是非前台的Activity—–比如Activity中的对话框，虽然可见但是位于后台无法和用户直接交互。 后台Activity—已经被暂停的Activity，比如执行了onStop，优先级最低 二、Activity的启动模式 standard ： 标准模式 系统的默认模式。一种多实例模式。每次启动一个Activity都会重新创建一个新的实例。被启动的Activity会被放入启动者的栈中，如果启动者是除Activit之外的Context，这时由于没任务栈所以报错，此时需要指定FLAG_ACTOVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，且这时候启动它实际上是以singleTask模式启动的。 singleTop ：栈顶复用模式 如果一个Activity的实例已经在栈顶存在，启动这个Activity时，并不会创建新的Activity，而会回调onNewIntent()。如果不是在栈顶存在，则会创建一个新的实例。 例如多个Activity如ABCD，若D为栈顶，当它为singleTop模式时，栈里仍为ABCD。，而如果为默认的standard模式时就会变成ABCDD。 适合接收通知启动的内容显示页面，当收到多条新闻推送时，用于展示新闻的Activity设置成此模式，根据传来的intent数据显示不同的新闻信息，不会启动多个Activity singleTask：栈内复用模式 一种单例模式。只要Activity的实例在一个栈中存在，再次启动Activity都不会创建实例，只会回调onNewIntent()，并从栈中弹出实例上面的所有Activity。 适合作为程序的入口点，例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewInetnt()，并且会清空主界面上的其他页面。 singleInstance ： 单实例模式 具有singleTask的所有特性，设置模式的Activity只能存在一个任务栈中。 例如闹钟的响铃界面。你以前设置了一个闹钟：上午6点。在5点58分时。你启动了闹钟的设置界面，并按home返回桌面；一分钟后，你在和朋友TIM上聊天。6点时，闹钟响了，并弹出对话框式的Activity（它就是以SingleInstance模式打开的）。此时你按返回键，你仍然在聊天界面，因为它的Activity所在的Task栈只有他的一个元素，因此退出后栈空。若是SingTask模式打开的Activity，则它返回后应该进入至设置界面 三、IntentFilter的匹配规则Activity的启动不是显示就是隐式，如果共存则是显示为主。而隐式调用则需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配则无法启动。 三种匹配规则如下： 1.action的匹配规则2.category的匹配规则3.data的匹配规则 四、一些问题补充：问：清晰的描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？ 答：onNewInetnt：在singleTop，singleTask，singleInstance再次启动同的Activity，如果期望只有一个实例存在，再次启动就会调用onNewIntent()，在onNewIntent可以通过setInetnt(intent)刷新intent数据。 onConfigurationChanged：如下 要注意的是从Android3.2后（API13），当设备旋转时，screen size也会改变，因此需要设置android:configChanges=”oraientation|screenSize” 问：onStart和OnResume、onPause和OnStop从描述上来看差不多，对我们来说有什么实质上的不同呢？ 答：从使用过程来说他们两对确实差不多，甚至可以只用一对，但他们两个配对的回调分别表示不同的意义，onStart和onStop是从是否可见的角度来回调的，而OnResume和OnPause是从Activity是否位于前台这个角度来回调的。 问：假设当前Activity为A，如果这时用户打开一个新的ActivityB，那么B的onResume和A的onPause哪个先执行呢？ 答A的onPause先调用，B的onResume再执行。原因的话在后面的工作原理会再次说明，这里先简单的说明结果。 学习小结通过这篇你学会了什么？ 1.Activity生命周期不同情况 2.Activity的启动模式 3.匹配规则 4.一些面试题的思考 参考资料：Android开发艺术，Planet。 当然关于Activity的工作过程有会专门的一篇来整理，那么我们继续看下去吧~ 1/1/2018 10:15:32 PM 第3次修改"},{"title":"四大组件之ContentProvider","date":"2018-01-05T02:33:24.000Z","updated":"2018-04-16T07:10:16.328Z","comments":true,"path":"不想提交TAT/ContentProvider.html","permalink":"https://markfrank01.github.io/不想提交TAT/ContentProvider.html","excerpt":"ContentProvider的回顾","text":"ContentProvider的回顾 引言 上篇我们了解和补充学习了BroadcastReceive，现在我们来继续往下走，这篇我们来重新补充学习一下ContentProvider。 清晰理解ContentProvider: 一、ContentProvider是什么 二、Binder的原理 三、ContentProvider的一些问题 一、ContentProvider是什么ContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式，从这来看它本身就适合进程间的通信。 它和Messager一样，ContentProvider的底层实现同样是Binder，虽然和AIDL底层实现相同但是系统为我们做了封装。所以我们无需关心底层的细节就可以轻松实现IPC。 二、Binder的原理这个地方需要我们重点去理解，先挖个坑，到时候我们专门有一篇学习IPC机制的Binder。 三、ContentProvider的一些问题问： ContentProvider是如何实现共享数据的？ 答： 继承ContentProvider并重写insert,query,…等重要方法。 在AndroidManifest.xml使用对该ContentProvider进行配置，为了能让其他应用找到该ContentProvider，ContentProvider需要采用了authorities（主机名/域名）对它进行唯一标识，然后再将数据添加到ContentProvider中。 在其它应用中通过ContentResolver使用定义的Uri访问并操作这些被暴露的数据。 问： ContentProvider如何控制数据访问权限？ 答： 向此应用设置一个android:sharedUserId，然后需要访问此数据的应用也设置同一个sharedUserId，具有相同的sharedUserId的应用间可以共享数据。但是这种方法不够安全，也无法做到对不同数据进行不同读写权限的管理。 使用ContentProvider中的数据共享规则 学习小结1.对ContentProvider进行了重新的回顾 2.重新补充一些Binder原理 3.重新回忆了ContentProvider共享数据和控制数据访问权限的办法"},{"title":"四大组件之BroadcastReceiver","date":"2018-01-03T12:03:11.000Z","updated":"2018-04-16T07:10:07.741Z","comments":true,"path":"不想提交TAT/BroadcastReceiver.html","permalink":"https://markfrank01.github.io/不想提交TAT/BroadcastReceiver.html","excerpt":"BroadcastReceiver的回顾","text":"BroadcastReceiver的回顾 引言 上篇我们了解和补充学习了Service，现在我们来继续往下走，这篇我们来重新补充学习一下BroadcastReceiver。 详解BroadcastReceiver的相关知识 BroadcastReceiver： 一、BroadcastReceiver是什么 二、BroadcastReceiver的实现原理 三、BroadcastReceiver的一些问题 BroadcastReceiver是什么BroadcastReceiver属于四大组件之一，分为两个角色，发送者和接收者，它主要用于监听或者接收应用App发出的广播消息，并做出响应。 Android不同组件之间的通信，多线程通信，与Android系统在特定的情况在通信（比如电话呼入，或者网络可用） 实现原理它使用了设计模式中的观察者模式： 即基于消息的发布或订阅事件的模型，和Rxjava采用的同样的设计模式。Android将BroadcastReceiver的发送者和接收者解耦，使得系统方便集成和方便扩展。 原理描述： 广播接收者 通过Binder机制在AMS（即Activity Manager Service 消息机制）注册 广播发送者 通过Binder机制向AMS发送广播 AMS根据广播发送者要求，在已注册列表中，寻找合适的广播接收者 AMS将广播发送到合适的广播接收者相应的消息循环队列中 广播接收者通过消息循环得到此广播，并回调onReceive()。 我们需要注意的是广播发送者和广播接收者是异步执行的，即广播发送者不关心是否有接收和什么时候才能接收到 BroadcastReceiver的一些问题问： 为什么动态广播最好在Activity的onResume（）注册、onPasue（）注销 答： 对于动态广播，有注册就必定需要注销，重复的注册，重复的注销也不可以 通过Activity的生命周期方法我们可以知道，在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。 问： 不同注册方式的广播接收器的onReceive(Context context,Intent intent)中的context返回值一样吗？他们的值是什么？ 答： 对于静态注册（全局+应用内广播），回调onReceive(context, intent)中的context返回值是：ReceiverRestrictedContext； 对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context； 对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context。 对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context； 学习小结这篇你学会了什么？ 1.BroadcastReceive实现原理的初步了解。 2.动态广播的注册和注销的地方 3.BroadcastReceive的onReceive的context返回值问题 我们接着往下走 1/5/2018 09:33:10 PM 第2次修改"},{"title":"新的旅程","date":"2017-03-01T09:12:20.000Z","updated":"2017-04-09T09:14:57.307Z","comments":true,"path":"不想提交TAT/MyFirst.html","permalink":"https://markfrank01.github.io/不想提交TAT/MyFirst.html","excerpt":"历经三天博客终于搭建好啦！","text":"历经三天博客终于搭建好啦！ 简介 Hello，大家好，我是博主嘉晨。我在大学的生活里，学习了一些技术并经历了一些开发。正所谓独乐乐不如众乐乐，今后的生活中我将不断给大家分享一些技术知识。因为热爱所以专注，希望大家一同学习，不断进步。 PS：你们要的博主头像 分类说明 因为博主进行的android学习开发较多，所以主要分享android知识(github地址)，当然一些辅助学习的知识博主也会慢慢的更新，诸如git。另外java基础知识的深入和数据结构的学习也是必不可少的，这个会另外分出来进行更新。 第一天:成长"},{"title":"tags","date":"2017-09-25T05:05:30.000Z","updated":"2017-09-25T05:21:45.679Z","comments":false,"path":"tags/index.html","permalink":"https://markfrank01.github.io/tags/index.html","excerpt":"","text":""},{"title":"RxLearning(RxJava 和 Retrofit学习系列)","date":"2017-09-15T08:39:05.000Z","updated":"2017-10-01T12:51:18.832Z","comments":true,"path":"不想提交TAT/RxLearning第一季第一篇.html","permalink":"https://markfrank01.github.io/不想提交TAT/RxLearning第一季第一篇.html","excerpt":"","text":"开端本系列RxLearning 一共四季12篇 本篇是第一季第一篇这个系列分别通过学习Rxjava,学习Retrofit 以及它们的结合使用进来新的世界RxJava 到底是什么？我为什么需要去学习它？我该如何去学习？别急我们一个个来分析。目前一些资料已经比较成熟，老规矩我们先放上一些资料的推荐再结合资料进行我们自己的学习。 首先掏出传世神作 来自扔物线大神的 《给 Android 开发者的 RxJava 详解》 然后还有通俗易懂的 Season_zlc的 《给初学者的RxJava2.0教程》 废话少说开始我们的表演。 引入Rxjava是什么？ “RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.” 相信很多人一看就有点慌，别怕 这个官方的定义：一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。对于初学者不是很友好，最初我也是看的一脸疑问，但是我们开始的时候记住一个关键词就够了：异步，从本质上来说其它的操作都是围绕这个词进行的展开。 我为什么需要学习它？话我觉得可以借用一句话来说明： Write Less Do More 简洁 二字贯穿其中，异步的操作随着逻辑越来越复杂，异步代码也经常会既难写也难被读懂，Rxjava相比于其它的方法，比如handle和AsyncTask 优势都是简洁， 不过Rxjava的链式调用使得即使程序逻辑变得越来越复杂，它依然能够保持简洁。 参考参考之前扔物线的资料： “假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行”。 拿出一种实现方式： new Thread() { @Override public void run() { super.run(); for (File folder : folders) { File[] files = folder.listFiles(); for (File file : files) { if (file.getName().endsWith(&quot;.png&quot;)) { final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() { @Override public void run() { imageCollectorView.addImage(bitmap); } }); } } } } }.start(); 而如果使用 RxJava ，实现方式是这样的： Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() { @Override public Observable&lt;File&gt; call(File file) { return Observable.from(file.listFiles()); } }) .filter(new Func1&lt;File, Boolean&gt;() { @Override public Boolean call(File file) { return file.getName().endsWith(&quot;.png&quot;); } }) .map(new Func1&lt;File, Bitmap&gt;() { @Override public Bitmap call(File file) { return getBitmapFromFile(file); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() { @Override public void call(Bitmap bitmap) { imageCollectorView.addImage(bitmap); } }); 什么？说好的简洁呢？不用担心，扔物线大神已经告诉了我们，代码简洁不单单是数量上的简洁，逻辑的简洁才更能提升读写的速度。通过这个例子我们大致的了解了一下学习它的原因和简洁的含义，我们接着往下走。 我该如何去学习？其实写到这有部分老哥们是有疑问的，既然开篇放上了大神资料我为啥还要看你这篇呢？图样图森破，吸取精华，根据自身进行沉淀，这才是提升自己能力并加强学习能力最好的方式。不同于深入的原理分析，不同于单纯的操作符介绍，我们这个系列将通过实例来一步步去学习。 附录上Demo地址。（PS:其实例子是我先已经写出来啦，只是拖更加上没有及时提交更新~ 不过下篇肯定不拖更哦）"},{"title":"打造自定义刷新加载框架(一)","date":"2017-04-10T15:15:32.000Z","updated":"2018-07-11T14:54:02.442Z","comments":true,"path":"不想提交TAT/MySwipeRefresh01.html","permalink":"https://markfrank01.github.io/不想提交TAT/MySwipeRefresh01.html","excerpt":"打造属于自己的刷新框架！","text":"打造属于自己的刷新框架！ 第一篇 自定义刷新加载框架（一）相信大家使用刷新加载的框架有很多,像官方的Swiperefreshlayout或是一些诸如SuperSwiperefreshlayout,XRecyclerView之类的,大家应该也用过其中一些,今天给大家分享如何一个自定义一个属于自己的刷新加载框架。分为两篇从两种不同方式来实现我们的需求。先看看我们实现的效果吧 我们需要做什么首先对于刷新加载的实现,我们首先需要想到的就是事件拦截,第一个思路我们从嵌套滑动的nestedscrolling下手，话不多说直接看代码。我们先看一下最重要的方法onNestedPreScroll 123456789101112131415161718192021222324252627282930313233343536373839 public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; if (totalY &lt; 0 &amp;&amp; myRecyclerView.isOrientation(0) || totalY &gt; 0 &amp;&amp; myRecyclerView.isOrientation(1)) &#123; isfling = true; &#125;//下拉刷新 if (IsRefresh) &#123; if (dy &gt; 0) &#123; //判断recyclerview为纵向而不是横向 if (myRecyclerView.isOrientation(0)) &#123; totalY += dy; if ((totalY / 2) &lt;= 0) &#123; scrollTo(0, totalY / 2); consumed[1] = dy; &#125; else &#123; scrollTo(0, 0); consumed[1] = 0; &#125; &#125; return; &#125; &#125;//上滑加载 if (IsLoad) &#123; if (dy &lt; 0) &#123; //判断recyclerview为纵向而不是横向 if (myRecyclerView.isOrientation(1)) &#123; totalY += dy; if ((totalY / 2) &gt;= 0) &#123; scrollTo(0, totalY / 2); consumed[1] = dy; &#125; else &#123; scrollTo(0, 0); consumed[1] = 0; &#125; &#125; return; &#125; &#125; &#125; 作为刷新，我们需要在onNestedPreScroll中去修改需要的x和y的值，这个时候就需要通过父的view进行拦截，那么我们通过对dy的判断即可以得出到底是在上滑还是在下拉，因为dy为正就是下拉，也就是刷新操作，dy为负就是上滑，也就是加载操作。 我们在子view滑动结束后还要进行一个处理123456 public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; if (dyUnconsumed != 0) &#123; totalY += dyUnconsumed; scrollTo(0, totalY / 2); &#125;&#125; 接着我们可以添加我们的header和footer //添加头部的view public void addHeaderView(View headerView, int headerHeight) { this.headerHeight = headerHeight; this.headerLayout.removeAllViews(); this.headerLayout.addView(headerView); LayoutParams layoutParams = new LayoutParams(LayoutParams.MATCH_PARENT, headerHeight); layoutParams.topMargin = -headerHeight; this.headerLayout.setLayoutParams(layoutParams); } //添加底部的view public void addFooterView(View footerView, int footerHeight) { this.footerHeight = footerHeight; this.footerLayout.removeAllViews(); this.footerLayout.addView(footerView); this.footerLayout.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, footerHeight)); } 既然都重写了nestedscrolling那么我们也顺便重写一下recyclerView private class MyRecyclerView extends RecyclerView { private StaggeredGridLayoutManager staggeredGridLayoutManager = null; private LinearLayoutManager linearLayoutManager = null; private GridLayoutManager gridLayoutManager = null; private boolean isScrollLoad = false; private boolean isScrollRefresh = false; public MyRecyclerView(Context context) { super(context); setVerticalFadingEdgeEnabled(false); setHorizontalFadingEdgeEnabled(false); setVerticalScrollBarEnabled(false); setHorizontalScrollBarEnabled(false); setOverScrollMode(OVER_SCROLL_NEVER); setItemAnimator(new DefaultItemAnimator()); } private void setMyLayoutManager(LayoutManager layoutManager) { if (layoutManager instanceof StaggeredGridLayoutManager) { staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager; } else if (layoutManager instanceof GridLayoutManager) { gridLayoutManager = (GridLayoutManager) layoutManager; } else if (layoutManager instanceof LinearLayoutManager) { linearLayoutManager = (LinearLayoutManager) layoutManager; } setLayoutManager(layoutManager); if (!isVertical()) { throw new NullPointerException(&quot;vertical!&quot;); } } //orientation // 0 menas down // 1 means up private boolean isOrientation(int orientation) { if (orientation == 0) return isCanPullDown(); else if (orientation == 1) return isCanPullUp(); return false; } private boolean isCanPullDown() { return !canScrollVertically(-1); } private boolean isCanPullUp() { return !canScrollVertically(1); } private boolean isVertical() { if (staggeredGridLayoutManager != null) return staggeredGridLayoutManager.getOrientation() == StaggeredGridLayoutManager.VERTICAL; else if (linearLayoutManager != null) return linearLayoutManager.getOrientation() == LinearLayoutManager.VERTICAL; else if (gridLayoutManager != null) return gridLayoutManager.getOrientation() == GridLayoutManager.VERTICAL; return false; } } 这样我们就可以自己使用自己的刷新框架啦。具体详见github的MySwipeRefresh01 有两点需要注意的：第一个就是加载和刷新的view,这两个是可以自己重写动画定制自己想要的view，目前我仅仅是添加了两个文字提示。第二个就是还可以根据需要添加如滑动阻尼，这里暂时还没有加入。 接下来我们需要自己去做一个能够用于实际工作中的SwipRefresh。 第二篇将和大家分析并且手把手做，敬请期待哦5/11/2017 12:19:44 PM 第4次修改"},{"title":"打造自定义刷新加载框架(二)","date":"2017-04-14T02:28:38.000Z","updated":"2018-07-11T15:27:24.879Z","comments":true,"path":"不想提交TAT/MySwipeRefresh02.html","permalink":"https://markfrank01.github.io/不想提交TAT/MySwipeRefresh02.html","excerpt":"打造属于自己且能实际使用的刷新框架！","text":"打造属于自己且能实际使用的刷新框架！ 第二篇 自定义刷新加载框架（二）上一篇我们了解了该如何自己去做一个自定义刷新，今天我们就来自己去写一个能够在实际的项目中使用的刷新吧~ 先附上地址具体详见github的MySwipeRefresh01 接下来我们一步步去分析吧~~๑乛◡乛๑ SmartAndroidWidgets 这个是作者之前两个版本的集合，之前的两个版本没有Demo所以还是自己写一个吧~ 使用方法compile &#39;me.rawnhwang.library:smart-android-widgets:1.0.0&#39; 它的使用非常的简单,因为它本身就是一个ViewGroup &lt;me.hwang.widgets.SmartPullableLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/layout_pullable&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/me.hwang.widgets.SmartPullableLayout&gt; 接着只要对于上拉和下拉的添加监听就可以了： mPullableLayout.setOnPullListener(new SmartPullableLayout.OnPullListener() { @Override public void onPullDown() { // 下拉回调 // do what you want do } @Override public void onPullUp() { // 上拉回调 // do what you want do } }); 作者还提醒了我们，一定要在下拉上拉回调成功执行后，使用stopPullBehavior方法结束清除状态。 mPullableLayout.stopPullBehavior(); 此外还有几个视图的属性可以使用 不过光使用的话我们就没有学习的意义啦，所以我们还要去看看具体的实现首先我们把library导进来看看具体的实现 哇 大家一看是不是突然觉得好复杂呀，其实不是哦，因为其中有一个加载界面和我们需要的刷新框架，那我们就看看它就行。 先定义一个接口来标识状态信息 /** * 控件状态 */ public interface State { int NORMAL = 0; // 正常状态 int PULL_DOWN = 1; // 下拉中 int PULL_DOWN_RELEASEABLE = 2; // 可释放下拉 int PULL_DOWN_RELEASE = 3; // 已释放下拉 int PULL_UP = 4; // 上拉中 int PULL_UP_RELEASEABLE = 5; // 可释放上拉 int PULL_UP_RELEASE = 6; // 已释放上拉 } 等会我们就能很清晰的知道我们的状态,接下来的三个接口呢一一说明下，OnPullListener是用来监听处理滑动的信息,OnChildScrollUpCallback是处理上滑成功的回调，OnChildScrollDownCallback则是处理下滑成功的回调。 public interface OnPullListener { void onPullDown(); void onPullUp(); } public interface OnChildScrollUpCallback { boolean canChildScrollUp(SmartPullableLayout parent, View child); } public interface OnChildScrollDownCallback { boolean canChildScrollDown(SmartPullableLayout parent, View child); } 首先前面说啦 我们可以自己选择是否启用下拉或者上拉的功能，那这个该怎么做呢，很简单我们在onFinishInflate()去做，onFinishInflate()是在视图加载后去回调的，我们在里面做出判断看是否启用了下拉和上拉 刚开始的时候头和尾部都为隐藏状态，开始只显示正常状态。当它接收到滑动状态的时候位置就开始发生改变。当头部滑动时，头视图隐藏在顶端，当尾部滑动时，尾视图隐藏在尾端,代码如下： for (int i = 0; i &lt; getChildCount(); i++) { View child = getChildAt(i); if (child == mPullableHeader) { // 头视图隐藏在顶端 child.layout(0, 0 - child.getMeasuredHeight(), child.getMeasuredWidth(), 0); } else if (child == mPullableFooter) { // 尾视图隐藏在末端 child.layout(0, mTarget.getMeasuredHeight(), child.getMeasuredWidth(), mTarget.getMeasuredHeight() + child.getMeasuredHeight()); } else { child.layout(0, 0, child.getMeasuredWidth(), child.getMeasuredHeight()); } } 接着我们需要重写事件拦截的重要方法onInterceptTouchEvent(),我们需要在里面判断事件触摸的类型。我们可以在里面进行动作判断，特别注意的是我们不能监听ACTION_DOWN,因为当ACTION_DOWN被拦截，后续所有触摸事件都会被拦截。 switch (event.getAction()) { case MotionEvent.ACTION_DOWN: { // 不拦截ACTION_DOWN，因为当ACTION_DOWN被拦截，后续所有触摸事件都会被拦截 intercept = false; break; } case MotionEvent.ACTION_MOVE: { if ((mTarget != null &amp;&amp; !ViewCompat.isNestedScrollingEnabled(mTarget))) { if (y &gt; mLastMoveY) { // 下滑操作 intercept = !canChildScrollUp(); } else if (y &lt; mLastMoveY) { // 上拉操作 intercept = !canChildScrollDown(); } } break; } case MotionEvent.ACTION_UP: { intercept = false; break; } } 事件拦截后我们就需要在onTouchEvent()方法中做具体的事件处理。 switch (event.getAction()) { case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: if (Math.abs(getScrollY()) &gt; ignorablePullRange) getParent().requestDisallowInterceptTouchEvent(true); if (enabled) doScroll(mLastMoveY - y); break; case MotionEvent.ACTION_UP: onStopScroll(); getParent().requestDisallowInterceptTouchEvent(false); break; } 可以看到我们的doScroll()方法和onStopScroll()方法,我们的具体逻辑就在这里。doScroll()方法这段代码比较长，我就简要的说明一下，我们传入y轴的值进去，判断到底是上拉还是下拉的操作。mLastMoveY - y值为正就是上拉，为负就是下拉。注意哈，上拉和下拉不意味着操作一定发生，用户还是可能取消此次操作，且滑动还是存在有效距离的，所以我们在达到有效距离后加入滑动阻力使滑动不至于失效。 onStopScroll()方法在滑动结束后对视图进行更新: private void onStopScroll() { if (Math.abs(getScrollY()) &gt;= effectivePullRange) { // 有效拉动行为 if (getScrollY() &lt; 0) { // 有效下拉行为 mLayoutScroller.startScroll(0, getScrollY(), 0, -(getScrollY() + effectivePullRange)); updateState(State.PULL_DOWN_RELEASE); } else if (getScrollY() &gt; 0) { // 有效上拉行为 updateState(State.PULL_UP_RELEASE); mLayoutScroller.startScroll(0, getScrollY(), 0, -((getScrollY() - effectivePullRange))); } } else { // 无效拉动行为 if (getScrollY() != 0) mLayoutScroller.startScroll(0, getScrollY(), 0, -getScrollY()); updateState(State.NORMAL); } } 然后是updateState()方法: private void updateState(int state) { switch (state) { case State.NORMAL: reset(); break; case State.PULL_DOWN: { if (currentState != State.NORMAL) rotateArrow(); tvHintPullDown.setText(R.string.smart_ui_pull_down_normal); } break; case State.PULL_DOWN_RELEASEABLE: { rotateArrow(); tvHintPullDown.setText(R.string.smart_ui_pull_down_release_able); } break; case State.PULL_DOWN_RELEASE: { setEnabled(false); ivArrowPullDown.setVisibility(View.INVISIBLE); ivProgressPullDown.setVisibility(View.VISIBLE); downProgressAnimation.start(); tvHintPullDown.setText(R.string.smart_ui_pull_down_release); if (mListener != null) { mListener.onPullDown(); } } break; case State.PULL_UP: { tvHintPullUp.setText(R.string.smart_ui_pull_up_normal); } break; case State.PULL_UP_RELEASEABLE: { tvHintPullUp.setText(R.string.smart_ui_pull_up_release_able); } break; case State.PULL_UP_RELEASE: { setEnabled(false); ivProgressPullUp.setVisibility(View.VISIBLE); upProgressAnimation.start(); tvHintPullUp.setText(R.string.smart_ui_pull_up_release); if (mListener != null) { mListener.onPullUp(); } } break; } currentState = state; } 如有需求我们可以传入自己的视图即可以自己定义自己的加载动画，具体的写法和库的具体实现还是移步至SmartAndroidWidgets 5/11/2017 12:19:44 PM 第4次修改"},{"title":"js异步和网络Api发展史","date":"2017-03-27T11:06:50.000Z","updated":"2017-04-09T04:12:10.489Z","comments":true,"path":"不想提交TAT/js异步和网络api发展史.html","permalink":"https://markfrank01.github.io/不想提交TAT/js异步和网络api发展史.html","excerpt":"从ajax到fetch，从回调到async，滑稽带你领略js异步和网络Api发展史。仅仅是速览不会深入","text":"从ajax到fetch，从回调到async，滑稽带你领略js异步和网络Api发展史。仅仅是速览不会深入 js是事件驱动的语言，单进程单线程。js主线程中有一个Event Loop（事件循环）。 js运行顺序js先执行一遍所有js文件，然后进入Event Loop，等到有事件进入，就执行事件处理程序，执行完后再次回到Event Loop。 举个例子: 123456setTimeout(()=&gt;&#123; console.log(\"hello\");&#125;,0);//死循环while(true)&#123;&#125; 如果你在浏览器中运行，页面会卡死（在一些浏览器中仍可以滚动），因为js不执行完，浏览器不会做任何响应。 上面的代码永远不会输出hello，因为setTimeout(...,0)，虽然是延时0ms，但还是会在下一个事件循环中被调用。 而后面的while循环是死循环，js引擎永远执行不完，所以不会进入事件循环的，也就永远执行不到timeout里的代码 更详细的介绍可在阮老师的博客中看见。 异步所以啥是异步呢？ 我们先讲异步的反义词同步。 同步就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。 比如你发出一个网络请求请求一个数据，程序一直等待数据返回，不返回就不继续执行，这就是同步。 异步要智能得多。在网络请求没有返回之前程序还会继续执行。 延迟一秒在不同语言中同步、异步的不同写法: JS 异步123456console.log(1);setTimeout(()=&gt;&#123; console.log(2);&#125;,1000);console.log(3);//输出 1 3 2 Java 同步123456System.out.print(1);//延迟1000msThread.sleep(1000);System.out.print(2);System.out.print(3);//输出 1 2 3 显然Java的同步跟符合人类的思想，顺序执行非常简单。 但JS的优势也特别明显，在延迟时程序不会卡死，而是继续执行下去。 回调（callback）回调是JS异步编程最常见的方式。 回调函数（callback）是什么？(逼乎) 12345function callback()&#123; console.log(\"hello\");&#125;setTimeout(callback,1000); 上面的callback()就作为回调函数，在1000ms后会被调用。 Ajax回到我们的主题，运用最广泛的网络api ajax就是以回调方式使用的。 123456789101112131415var xmlhttp;xmlhttp=new XMLHttpRequest();//定义回调函数xmlhttp.onreadystatechange=function()&#123; //如果请求完成 且 返回状态码为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //输出内容 console.log(xmlhttp.responseText); &#125;&#125;xmlhttp.open(\"GET\",\"https://about.huaji8.top/links.json\",true/*异步运行*/);//发送xmlhttp.send(); 复制到浏览器console可以运行。 jquery封装的ajax写法要比原版简单的多，对这是原版。 ajax也可以同步运行，只要将XMLHttpRequest.open()最后一个参数改成false，就是同步运行，执行send()后浏览器会卡住，直到请求返回。 Promise （承诺）Promise是一种更高级的回调接口。 详细的介绍在这ECMAScript 6 入门，Promise的好处千千万，建议大家全部使用Promise，jquery的所有异步api也全部支持Promise ES6 原生支持 Promise ， 在不支持的浏览器上可以使用垫片库 es6-promise 下面是一个将setTimeout()改造成Promise的例子。 1234567891011121314151617181920//返回一个Promise 就可以无限then()啦 还可以用catch()捕获异常function setTimeoutP(ms)&#123; //创建Promise 如果成功就调用resolve，失败就调用reject return new Promise((resolve,reject)=&gt;&#123; setTimeout(resolve,ms); &#125;)&#125;setTimeoutP(1000).then(()=&gt;&#123; console.log('Hello'); // 返回Promise 可以在then()中继续执行 return setTimeoutP(1000);&#125;).then(()=&gt;&#123; console.log('world'); // 返回数据 可以在then()中获取 return 123;&#125;).then((r)=&gt;&#123; console.log(r);&#125;)//一秒后输出Hello fetchfetch 是新的网络api 基于 Promise 设计。在旧的浏览器上可以使用 isomorphic-fetch，这个api是 node 和 浏览器环境通用的，实现同构应用必备的库。 注：同构(isomorphic/universal)就是使前后端运行同一套代码的意思，后端一般是指 NodeJS 环境。 范例123fetch(\"https://about.huaji8.top/links.json\") .then((e)=&gt;&#123;return e.json()&#125;) .then((e)=&gt;&#123;console.log(e)&#125;); 尝试在浏览器console中运行 Generator 函数Generator 函数 是 ES6 提供的语法，不过很快就被 ES2017 的 async 函数 代替，所以不多说了，感兴趣的可以看ECMAScript 6 入门 第一次看到 Generator 函数 是在 unity 中的协程，现在js也有这个语法了。 async 函数重头来了，这是目前最屌的写法，真正用同步的写法写异步程序。 async 实际是 Generator 函数 的语法糖， Generator 才是技术 我们继续拿上面建的 setTimeoutP() 举例。 123456789101112131415161718//返回一个Promisefunction setTimeoutP(ms)&#123; //创建Promise 如果成功就调用resolve，失败就调用reject return new Promise((resolve,reject)=&gt;&#123; setTimeout(resolve,ms); &#125;)&#125;async function asyncDelay()&#123; // await可以拿到Promise的返回值 let O = await fetch(\"https://about.huaji8.top/links.json\") .then((e)=&gt;&#123;return e.json()&#125;) await setTimeoutP(1000) console.log(O); //一秒后输出 https://about.huaji8.top/links.json 内容&#125;asyncDelay(); 尝试在浏览器console中运行 async 异常处理async 可以以同步的方式编写异常处理。 123456789101112async function asyncDelay()&#123; try&#123; let O = await fetch(\"https://about.huaji8.top/links.json\") .then((e)=&gt;&#123;return e.json()&#125;) &#125;catch(e)&#123; //输出异常 console.log(e) .... &#125; await setTimeoutP(1000) console.log(O);&#125; 是不是超级方便呢。 关于async的更多信息，可以查看ECMAScript 6 入门或MDN"},{"title":"one - hexo单页面炫酷主题","date":"2017-03-18T02:12:10.000Z","updated":"2017-04-09T04:12:10.490Z","comments":true,"path":"不想提交TAT/one主题.html","permalink":"https://markfrank01.github.io/不想提交TAT/one主题.html","excerpt":"历经一个半月one主题终于完成！","text":"历经一个半月one主题终于完成！ 项目Github 其实我感觉是做的挺好看的，希望大家喜欢！ 截图 封面画师:loundraw"},{"title":"web动画框架的初步设计","date":"2017-03-22T11:38:00.000Z","updated":"2017-04-09T04:12:10.490Z","comments":true,"path":"不想提交TAT/web动画框架的初步设计.html","permalink":"https://markfrank01.github.io/不想提交TAT/web动画框架的初步设计.html","excerpt":"我希望有一天webApp能够达到原生应用的用户体验。","text":"我希望有一天webApp能够达到原生应用的用户体验。 最后证实是重复造轮子，人家还比我造的好太多，大家都散了吧。 （ 让我哭一会https://github.com/berzniz/react-overdrive 第一次写这么复杂的东西，我的语文水平我自己清楚，看不懂的可以直接到下面评论区夸我了。 缘起我是怎么喜欢上material design的？ 多半是因为这张炫酷的图。 哇！炫酷！流畅！ 我立即搜索material design的前端框架，发现没有一款可以实现这种效果的。 什么？？？？ 我大前端连区区一个动画都搞不定！！！ codepen上的虽然有类似的特效，但从复用性，性能等方面考虑都没有能作为框架的。 于是开始造轮之路。 效果初步实现的效果图： 效果可能不是很好，可能是因为没有调整动画曲线，不过这都是小问题。源码需要重构，不好意思拿出来。感兴趣的话可以联系我。 思路我们将前面的炫酷ui可以分成两部分。 上面这两个界面分开来的话，相信对各位前端大神都是小菜一碟的吧。 这个框架的思路就是用程序来自动补间。 我们在每个元素身上放个key。 先记录下所有被标记的元素的位置。 页面改变后将其自动补间到新的位置。包括高度宽度等css属性。 嗯，但这个补间怎么做？js？css transition？ 显然css transition是更高效的选择，要使用css transition的前提就是页面的转换不能破坏这个元素。 现有路由库如：react-router等，都是删掉原来的元素，填入新的元素，所以css transition是行不通的。 然而我选了一种特别极端的方法，添加一个布局层。 布局层 上图红色部分就是布局层，布局层没有显示，没有动画，由路由负责管理。 图片中有内容的元素是绝对定位的，存在在布局层之上，不受路由管理，称为Plane(面)。 用程序把Plane放在对应的布局层之上，设置高度宽度，加上css transition。当布局层发送改变时，刷新Plane的位置，高度，宽度，内容。这个过程中Plane是不会被重建的于是css transition就产生了补间动画。 得益于react的 vdom 和 jsx 我们可以按正常的方式写元素，然后把他们渲染在其他地方。 再说下这个站 这个站也有布局转换的过渡效果。 ](/img/web动画框架的初步设计/垃圾1.png)![ 可以看到布局变化后，原来的元素并没有被清理，codepen上许多方案也有这种缺陷，页面一多，就会有很多元素，肯定不行。 这篇文章的方法会真正释放掉旧的元素，也算个优点。 结尾如果你有更好的方法欢迎与我讨论。 封面画师: 秋月"},{"title":"hexo的live2d插件","date":"2017-01-29T08:29:29.000Z","updated":"2017-04-09T04:12:10.489Z","comments":true,"path":"不想提交TAT/hexo的live2d插件.html","permalink":"https://markfrank01.github.io/不想提交TAT/hexo的live2d插件.html","excerpt":"为你的hexo添加色气满满的live2d吧！","text":"为你的hexo添加色气满满的live2d吧！ [ npm version](https://badge.fury.io/js/hexo-helper-live2d.svg) loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-EYHN-hexo-helper-live2d-81d768d\", \"EYHN\", \"hexo-helper-live2d\", \"81d768d\", false); hexo-helper-live2d为你的hexo添加色气满满的live2d吧！ 1npm install -save hexo-helper-live2d Example: https://delusion.coding.me/ z16 食用方法：1npm install -save hexo-helper-live2d 将下面的代码加入主题。 12345678910111213&lt;canvas id=\"live2dcanvas\" width=\"300\" height=\"600\" class=\"live2d\"&gt;&lt;/canvas&gt;&lt;%- live2d(\"live2dcanvas\") %&gt;&lt;style&gt;.live2d&#123; position: fixed; bottom: -30px; right: 0px; z-index: 999; width: 150px; height: 300px; pointer-events: none;&#125;&lt;/style&gt; Enjoy! 暂时还不能添加其他模型，不过很快就会更新，所以请点个watch实时追踪更新吧！ 我第一个hexo插件,点个star,点个watch吧。 Github: https://github.com/EYHN/hexo-helper-live2d issues: https://github.com/EYHN/hexo-helper-live2d/issues 求英文好的小伙伴提交一个英文版的README，直接提交PR就可以啦! About me[ Author](https://img.shields.io/badge/author-cneyhn-green.svg?style=flat-square) [ QQ](https://img.shields.io/badge/QQ-1106996185-blue.svg?style=flat-square) [ Email License 许可证[ license](https://img.shields.io/github/license/EYHN/hexo-helper-live2d.svg?style=flat-square) Open sourced under the GPL v2.0 license. 根据 GPL V2.0 许可证开源。"},{"title":"js获取元素绝对位置","date":"2017-03-20T11:30:50.000Z","updated":"2017-04-09T04:12:10.489Z","comments":true,"path":"不想提交TAT/js获取元素绝对位置.html","permalink":"https://markfrank01.github.io/不想提交TAT/js获取元素绝对位置.html","excerpt":"众：哇！不会吧！博主你这都不会！ 我：我…我还真的不会。","text":"众：哇！不会吧！博主你这都不会！ 我：我…我还真的不会。 今天搞事情想搞个react动画框架。需要获取元素的绝对位置。 百度： 不要和我说google 一样的货色 123456789101112//获取元素的纵坐标 function getTop(e)&#123; var offset=e.offsetTop; if(e.offsetParent!=null) offset+=getTop(e.offsetParent); return offset; &#125; //获取元素的横坐标 function getLeft(e)&#123; var offset=e.offsetLeft; if(e.offsetParent!=null) offset+=getLeft(e.offsetParent); return offset; &#125; 嗯 很合理嘛 Element.offsetTop + 递归。 可偶然发现这是获取元素在文档流中的位置，但 transform 属性是不会改变文档流中的位置的。好，我们换一个方法。结果百度 google翻了几页都是这一个方法 继续寻找，突然想到jq，试了一下jq的offset方法，完美支持 transform 属性，mmp。 经查看jq源码，方法如下： 123456789101112131415161718192021222324252627282930313233343536offset: function( options ) &#123; // Preserve chaining for setter if ( arguments.length ) &#123; return options === undefined ? this : this.each( function( i ) &#123; jQuery.offset.setOffset( this, options, i ); &#125; ); &#125; var doc, docElem, rect, win, elem = this[ 0 ]; if ( !elem ) &#123; return; &#125; // Return zeros for disconnected and hidden (display: none) elements (gh-2310) // Support: IE &lt;=11 only // Running getBoundingClientRect on a // disconnected node in IE throws an error if ( !elem.getClientRects().length ) &#123; return &#123; top: 0, left: 0 &#125;; &#125; rect = elem.getBoundingClientRect(); doc = elem.ownerDocument; docElem = doc.documentElement; win = doc.defaultView; return &#123; top: rect.top + win.pageYOffset - docElem.clientTop, left: rect.left + win.pageXOffset - docElem.clientLeft &#125;;&#125; 查阅mdn的 getBoundingClientRect() 词条。 Range.getBoundingClientRect() 返回一个 ClientRect 对象，该对象限定了选定的文档对象的内容，该方法返回了一个矩形，这个矩形包围了该文档对象中所有元素的边界矩形集合（译者注：关于边界矩形可以参考 Minimum Bouding Rectangles）。 以及 getClientRects() 返回值是ClientRect对象集合，该对象是与该元素相关的CSS边框。每个ClientRect对象包含一组描述该边框的只读属性——left、top、right和bottom，单位为像素，这些属性值是相对于视口的top-left的。即使当表格的标题在表格的边框外面，该标题仍会被计算在内。 注意上文的 这些属性值是相对于视口的top-left的。 也就是说算出元素在页面的绝对位置还有加上视口滚动的距离。 所以jq的实现就是： 1234&#123; top: 元素顶部到视口顶部 + 视口到页面顶部 - 文档偏移 left: 元素左侧到视口左侧 + 视口到页面左侧 - 文档偏移&#125; 封面画师: squidsmith"},{"title":"Todo-mvp","date":"2018-06-07T13:13:32.000Z","updated":"2018-07-22T10:41:50.228Z","comments":true,"path":"不想提交TAT/mvp.html","permalink":"https://markfrank01.github.io/不想提交TAT/mvp.html","excerpt":"让我们一起来看看官方的todp-mvp","text":"让我们一起来看看官方的todp-mvp 列表与详情 新建与统计 分包则按照功能进行分包 androidTest(UI层的测试) 、 androidTestMock（UI层测试mock数据支持）、test（业务层单元测试）、mock（业务层单元测试mock数据支持）：一、开端我们首先来开两个Base接口，BaseView与BasePresenter，两类分别是所有View和Presenter的基类。 1、首先来看两个Base接口类，BaseView与BasePresenter，两类分别是所有View和Presenter的基类。 public interface BaseView&lt;T&gt; { // 规定View必须要实现setPresenter方法，则View中保持对Presenter的引用。 void setPresenter(T presenter); } setPresenter的调用时机是presenter实现类的构造函数中，如此View中的事件请求便通过调用presenter来实现。 public interface BasePresenter { // 规定Presenter必须要实现start方法。 void start(); } 该方法的作用是Presenter开始获取数据并调用View的方法来刷新界面，其调用时机是在Fragment类的onResume方法中。 2、定义了契约类（接口）。使用契约类来统一管理view与presenter的所有的接口，这种方式使得view与presenter中有哪些功能，一目了然，维护起来也很方便。以下通过详情界面（功能）来分析： /** * This specifies the contract between the view and the presenter. */ public interface TaskDetailContract { interface View extends BaseView&lt;Presenter&gt; { // 设置数据加载状态 void setLoadingIndicator(boolean active); // 处理task加载失败的情况 void showMissingTask(); // 隐藏待办事项title void hideTitle(); // 显示待办事项title void showTitle(String title); // 隐藏待办事项的描述 void hideDescription(); // 显示待办事项的描述 void showDescription(String description); …… } interface Presenter extends BasePresenter { // 修改待办事项 void editTask(); // 删除待办事项 void deleteTask(); // 标记完成 void completeTask(); // 标记未完成 void activateTask(); } } TaskDetailContract中的View接口定义了该界面（功能）中所有的UI状态情况，TaskDetailFragment作为View层，实现了该接口，如此 TaskDetailFragment 只关注UI相关的状态更新，所有事件操作都调用 TaskDetailPresenter 来完成。 Presenter 接口则定义了该界面（功能）中所有的用户操作事件，TaskDetailPresenter 作为Presenter层，实现了该接口，如此 TaskDetailPresenter 则只关注业务层的逻辑相关，UI的更新只需调用View的状态方法。 3、Activity在mvp中的作用。Activity在项目中是一个全局的控制者，负责创建view以及presenter实例，并将二者联系起来。TaskDetailActivity 的onCreate()回调中创建TaskDetailPresenter 实例，TaskDetailPresenter 的构造函数中实现了View和Presenter的关联。 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); …… // Create the presenter new TaskDetailPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), taskDetailFragment); } public TaskDetailPresenter(@Nullable String taskId, @NonNull TasksRepository tasksRepository, @NonNull TaskDetailContract.View taskDetailView) { this.mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository, &quot;tasksRepository cannot be null!&quot;); // 保持对View（TaskDetailFragment）的引用 mTaskDetailView = checkNotNull(taskDetailView, &quot;taskDetailView cannot be null!&quot;); // 使View（TaskDetailFragment）也保持对自身（TaskDetailPresenter）的引用 mTaskDetailView.setPresenter(this); } 4、Model层。该项目中Model层最大的特点是被赋予了数据获取的职责，与我们平常Model层只定义实体对象截然不同。实例中，数据的获取、存储、数据状态变化都是Model层的任务，Presenter会根据需要调用该层的数据处理逻辑并在需要时将回调传入。我们来看TaskDetailPresenter 的 start() 方法： @Override public void start() { openTask(); } private void openTask() { // 判空处理 if (null == mTaskId || mTaskId.isEmpty()) { mTaskDetailView.showMissingTask(); return; } // 更新状态 mTaskDetailView.setLoadingIndicator(true); // 获取该条Task数据 mTasksRepository.getTask(mTaskId, new TasksDataSource.GetTaskCallback() { @Override public void onTaskLoaded(Task task) { // The view may not be able to handle UI updates anymore // View已经被用户回退 if (!mTaskDetailView.isActive()) { return; } // 获取到task数据，并更新UI mTaskDetailView.setLoadingIndicator(false); if (null == task) { mTaskDetailView.showMissingTask(); } else { showTask(task); } } @Override public void onDataNotAvailable() { // The view may not be able to handle UI updates anymore // 显示数据获取失败时的状态 if (!mTaskDetailView.isActive()) { return; } mTaskDetailView.showMissingTask(); } }); } 我们接着看 TasksRepository 中的getTask() 方法， @Override public void getTask(@NonNull final String taskId, @NonNull final GetTaskCallback callback) { // 判空处理 checkNotNull(taskId); checkNotNull(callback); // 获取缓存数据 Task cachedTask = getTaskWithId(taskId); // Respond immediately with cache if available if (cachedTask != null) { callback.onTaskLoaded(cachedTask); return; } // Load from server/persisted if needed. // Is the task in the local data source? If not, query the network. // 从本地数据源（SQLite数据库）中获取 mTasksLocalDataSource.getTask(taskId, new GetTaskCallback() { @Override public void onTaskLoaded(Task task) { // 成功，则回调 callback.onTaskLoaded(task); } @Override public void onDataNotAvailable() { // 失败，则从远程数据源（网络）中获取 mTasksRemoteDataSource.getTask(taskId, new GetTaskCallback() { @Override public void onTaskLoaded(Task task) { // 回调成功时的方法 callback.onTaskLoaded(task); } @Override public void onDataNotAvailable() { // 回调失败时的方法 callback.onDataNotAvailable(); } }); } }); } 我们发现 TasksRepository 维护了两个数据源，一个是本地（SQLite数据库），一个是远程（网络服务器）。 private final TasksDataSource mTasksRemoteDataSource; private final TasksDataSource mTasksLocalDataSource; 我们发现他们（包括TasksRepository类）都实现了 TasksDataSource 接口： public interface TasksDataSource { interface LoadTasksCallback { void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); } interface GetTaskCallback { void onTaskLoaded(Task task); void onDataNotAvailable(); } void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); void completeTask(@NonNull Task task); void completeTask(@NonNull String taskId); void activateTask(@NonNull Task task); void activateTask(@NonNull String taskId); void clearCompletedTasks(); void refreshTasks(); void deleteAllTasks(); void deleteTask(@NonNull String taskId); } 这样一来我们就很容易扩展新的数据源（获取数据的方式），毕竟我们在TaskDetailActivity中初始化TasksRepository就是调用的如下方法，其实我们很容易把FakeTasksRemoteDataSource替换为TasksRemoteDataSource，把TasksLocalDataSource 替换为TasksContentProviderDataSource，这就是针对接口编程的好处吧。 public static TasksRepository provideTasksRepository(@NonNull Context context) { checkNotNull(context); return TasksRepository.getInstance(FakeTasksRemoteDataSource.getInstance(), TasksLocalDataSource.getInstance(context)); } 小结最后，我们再来看这张图。Fragment作为View，View和Presenter通过Activity来进行关联，Presenter对数据的调用是通过TasksRepository来完成的，而TasksRepository维护着它自己的数据源和实现。 二、进入MVP的运作过程，大致可以这么理解：View给Presenter指派任务，然后Presenter调控一个或多个Model， 给它们划分各种小任务，配合完成任务。然后Presenter根据任务的完成情况，通知View更新UI。 注意事项 1.View只负责简单的视图更新、界面跳转的代码。 2.View和Presenter的交互，是用接口来实现的。 3.View及时切断与Presenter的关联。 4.Model，作为数据源，要确保它的可复用性。 5.Context。如果你要在Presenter和Model里面使用Context，那么你应该使用Application的Context，而不是Activity的Context。 1）避免自己偷懒，在Presenter和Model执行更新UI的操作。实际上，这也是很不应该的操作。 2）避免Context在子线程使用时，由于Activity突然被销毁，导致的空指针。 3）Application的Context足够应付Presenter和Model里面的需求了。 6.构造方法，要使用依赖注入。 由于篇幅原因我打算分开写，未完待续哦。"},{"title":"通过css 3d transform让页面变3d","date":"2017-03-26T01:48:29.000Z","updated":"2017-04-09T04:12:10.490Z","comments":true,"path":"不想提交TAT/通过css 3d transform让页面变3d.html","permalink":"https://markfrank01.github.io/不想提交TAT/通过css 3d transform让页面变3d.html","excerpt":"通过css 3d transform让页面变3d。","text":"通过css 3d transform让页面变3d。 我只是实在想不到写什么，水文罢了。 顺便试试hexo的html,连js都可以写。 预览3D (function(){ var flag = false; $(\"body\").css({ \"transition\": \"all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms\" }) function postCSS3d(){ if(flag == false){ flag = true; $(\"body\").css({ \"transform\": \"perspective(6000px) rotateY(30deg) translateZ(-1000px) translateX(550px)\", \"transform-style\": \"preserve-3d\", \"perspective-origin\": \"50% 1000px\", \"height\": \"100%\", \"overflow\": \"scroll\", \"pointer-events\": \"auto\" }) $(\"html\").css({ \"height\": \"100%\" }) }else{ flag = false; $(\"body\").css({ \"transform\": \"inherit\", \"transform-style\": \"inherit\", \"perspective-origin\": \"inherit\", \"height\": \"inherit\", \"overflow\": \"inherit\", \"pointer-events\": \"inherit\" }) $(\"html\").css({ \"height\": \"inherit\" }) } } window.postCSS3d = postCSS3d; })() 代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;button id=\"3Dtransition\"&gt;3D&lt;/button&gt;&lt;script&gt; (function()&#123; var flag = false; $(\"body\").css(&#123; \"transition\": \"all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms\" &#125;) function postCSS3d()&#123; if(flag == false)&#123; flag = true; $(\"body\").css(&#123; \"transform\": \"perspective(6000px) rotateY(30deg) translateZ(-1000px) translateX(550px)\", \"transform-style\": \"preserve-3d\", \"perspective-origin\": \"50% 1000px\", \"height\": \"100%\", \"overflow\": \"scroll\", \"pointer-events\": \"auto\" &#125;) $(\"html\").css(&#123; \"height\": \"100%\" &#125;) &#125;else&#123; flag = false; $(\"body\").css(&#123; \"transform\": \"inherit\", \"transform-style\": \"inherit\", \"perspective-origin\": \"inherit\", \"height\": \"inherit\", \"overflow\": \"inherit\", \"pointer-events\": \"inherit\" &#125;) $(\"html\").css(&#123; \"height\": \"inherit\" &#125;) &#125; &#125; $(\"3Dtransition\").onClick(postCSS3d); &#125;)()&lt;/script&gt; PS我发现有些人js是定义是写在全局的@halyul，这不是好习惯，变量多了容易重复定义。 123(function()&#123; ...&#125;)() 这种写法可以避免这个问题。 等同于： 12345function a()&#123;&#125;a() 再见封面画师: Miv4t"},{"title":"行动指南","date":"2017-10-15T11:47:36.000Z","updated":"2017-10-15T12:53:41.972Z","comments":true,"path":"不想提交TAT/行动指南.html","permalink":"https://markfrank01.github.io/不想提交TAT/行动指南.html","excerpt":"","text":"近期行动指南为什么要写这个行动指南呢？ 因为最近状态并不是特别棒，所以写下此文作为近期总结与反思，为的是更好的督促自己做的更好！此文作为一个记录将长期持续更新。 罗列目前状况 (2017.10.15)目前需要学习的地方（PS: 想到再补充）：- Rxjava2 和 Retrofit2 think in java 细读 数据结构补充学习 一些源码的学习 目前的实现方式（PS:想到再补充）：- 开启新的博客专栏《每日一View》，并按时的去更新。 学习并梳理知识逐步形成自己的知识体系，多做笔记，《RxLearning》系列需要补充更新。 更新实战项目 HappyEnglish 并将其重构 书籍需要多读几遍。 日常更新gayhub, sorry 是 github 生活状况目前生活状态不错，坚持每天去锻炼锻炼，关键是减肥TAT。 那不错的状态指的是什么嘞。Stay hungry Stay foolish。 我更喜欢它的原意，也就是直译啦。当然配上原图 stay hungry,stay foolish 直译是什么嘞：就是别理他们，继续当你的傻瓜。因为要革命，你就注定要在众人的误会中孤独的前进。在质疑中前进，这很难 引用HappyEnglish中的一句~~ begin 所以也希望我可以坚持下去。 PS:补充附上这些一定要完成~ remember"},{"title":"Git笔记----Git的使用","date":"2017-10-10T08:15:43.000Z","updated":"2017-10-14T15:56:43.809Z","comments":true,"path":"不想提交TAT/Git笔记.html","permalink":"https://markfrank01.github.io/不想提交TAT/Git笔记.html","excerpt":"Git学习和使用全记录","text":"Git学习和使用全记录 为什么要学习gitGit是目前世界上最先进的分布式版本控制系统（没有之一）。说白了就是可以方便的管理你的版本修改记录，简单易学而且好用。这篇文章当作我自己的一个学习笔记，在我学习的过程中主要看了这两个教程，地址如下： 廖雪峰Git教程：简单易懂，讲的比较详细基本。 介绍Android Studio使用Git最详细的文章。：这篇我是在郭霖大神的公众号上看到的，非常棒的Android Studio使用Git的文章接下来我来整理一下吧 ##全新的开始 ###基本命令收集git init：将目录变成Git可以管理的仓库 ls -al：查看当前文件夹所有目录 git add . (file)：.为将所有目录提交到缓存区,filename即为单个文件可以连缀提交多个文件 git commit -m “xxxxxx”：将缓存区所有目录，提交到本地仓库 git status：查看仓库的当前状态 git diff (file)：可以查看修改的内容 git log (–pretty=oneline)：显示最近到最远的提交日志,参数可以让日志单行简略显示 git reset –hard HEAD：回退到上一个版本 git reset –hard (版本号)：回退到匹配号版本,git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。 git reflog：记录历史命令 git checkout – file：文件在工作区的修改全部撤销 git rm file：删除该文件 git checkout – file：还原文件到最新的版本 git remote add origin git@github.com:xxx/xxx.git：将远程仓库与一个已有的本地仓库关联 git push -u origin master：将本地库的所有内容推送到远程仓库 git checkout -b dev：创建dev分支，并切换到dev分支相当于~ git branch dev 创建 git checkout dev切换到dev分支 git branch：查看当前分支 git merge dev： 在master分支中将dev分支合并到master分支中 git branch -d dev：删除dev分支 git merge –no-ff dev：使用–no-ff参数禁用Fast forward git stash：暂存当前工作 git stash list：查看暂存列表,一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了. git tag (xxx commiti)：加参数即为为某个commit打上标签名，不加为查看所有标签 git tag -d tagname：删除标签 git push origin tagname：推送某个标签到远程 git push origin –tags： 一次性推送全部尚未推送到远程的本地标签"},{"title":"四大组件之Service","date":"2018-01-02T11:45:33.000Z","updated":"2018-04-16T07:10:04.787Z","comments":true,"path":"不想提交TAT/Service.html","permalink":"https://markfrank01.github.io/不想提交TAT/Service.html","excerpt":"Service的回顾","text":"Service的回顾 引言 上篇我们学习了Activity的一些进阶知识，这篇我们来学习一下Service。它有哪难的呢，确实用起来不难，但是详细的追根揭底就会有一些概念不够清晰了，所以我们需要再去复习一下。 清晰理解Service。 问题思考： 一.Service是什么 二、Service的start和bind状态有什么区别？ 三、同一个Service，先startService，然后再bindService，如何把它停止掉？ 四、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 五、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ 一.Service是什么？这个问题很多人觉得不应该放在这里，但是通过我问周边的一些同事，发现还真没几个人能完全的答对。那么Service究竟是什么呢？ Service是Android中现实程序后台运行的解决方案，它非常适合去处理那些不需要交互但是需要长时间运行的任务。Service的运行不依赖于任何的用户界面，即使程序被切换到后台或者打开另外的应用，它仍然可以正常运行。 二、Service的start和bind状态有什么区别？start启动的Service，Service有独立的生命周期，不依赖该组件。多次调用start方法，会重复调用onStartCommand方法；且start启动的Service，必须通过stopService或者stopSelf来停止service(IntentService会自动调用stopSelf方法)。 多次调用bind方法，只会调用一次onBind方法。bind绑定的Service,Service依赖于这些组件，这些组件全部销毁后，Service也会被销毁 三、同一个Service，先startService，然后再bindService，如何把它停止掉？不管被startService调用几次，只需要stopService一次 同一个组件多次bind一个Service，并不需要多次调用unbind，只需要一次。 在stopService或者unbindService方法会导致Service的onDestory被执行 四、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 五、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？Service默认是运行在主线程的，所以它的生命周期也是运行在主线程。所以如果想要在Service中执行耗时操作，必须另起线程（或者使用intentService），否则可能会产生ANR。 学习小结通过这篇学会了什么？ 1.巩固了一下Service的概念 2.清晰的理解了Service 3.对于Service的生命周期和它的操作重新进行了学习 参考资料：Android开发艺术，Planet。 1/3/2018 10:15:32 PM 第3次修改"}],"posts":[{"title":"公元时刻","slug":"公元时刻","date":"2018-12-31T05:54:58.000Z","updated":"2018-12-31T08:02:30.409Z","comments":true,"path":"2018/12/31/公元时刻/","link":"","permalink":"https://markfrank01.github.io/2018/12/31/公元时刻/","excerpt":"没有人可以回到过去重新开始，但谁都可以从现在开始，书写一个别样的人生","text":"没有人可以回到过去重新开始，但谁都可以从现在开始，书写一个别样的人生 2018总结回顾2018有太多的失败的地方，也有一些目标远远没有完成，但很幸运的，我完成和坚持了一些小事。 对英语进一步学习，包括口语及阅读，能和外国人较为正常沟通 读完了30本书，并有详细的阅读笔记 完成了自我成长体系的构思及实践 认识了很多同行及其它行业的大佬，并向他们取经借鉴经验，尝试走自己的路 英语英语 ： 在流利说中不断学习，常有人问我学这个有没有用，每天打卡有没有用。抱歉，我只想说，对你没用。如果现在还有人质疑英语，他也许思维还石器时代。打卡也不过是一个正向反馈，也不是为了给别人看的，而是给自己。英语学习本就是一个长期或是说需要以年为单位进行学习，真正反馈也许是数年之后，我想没几个人能坚持这么久吧。 读书读书 : 读书的方式多种多样，并无好坏之分。但手机读书实在不是明智的选择，精力太容易分散了。 你这一秒在看着微信读书，下一秒飞来一个微信弹窗，然后又弹出一个TIM消息，估计这个读书就不会再切回来了。如果喜欢读书又不想背着纸质书，Kindle绝对是最好的选择。读书的类型 ： 我读的大部分比较偏思考类，而非工具类，工具书是提升技术的好办法，但生活远远不止技术。理财，思想，历史都是我看的比较多的。 2018的方向18年是我成长最快的一年，不仅是技术上，更是视野上。 今年尝试的几个方面OPT(Other people time)OPM(Other people money)OPT(Other people technology)OPP(Other people power) 这几个可能会让很多人不开心，所以我也不解释，熟悉我的人自然明白这是什么意思。 2019的展望 规划好时间，做更多自己想做的事 英语更加系统化的学习 技术进一步提升 理财坚持实践 读书更加系统化 理财 关于A股，很多人谈A股就无奈，这很正常，受益和风险永远是对等的，能承受多大的风险就能承受多大的受益。 关于定投，我个人不大看好，与其让别人替你操作，不如直接让他把钱给你。不是定投不好，而是这种思路不好，可以说定投的每个人都很有梦想，都想在未来拿到收益，可是如果是告诉你这个是零向定投呢，你还敢继续投吗，此处遵循第一条。 关于周期，定投的人我也见过很多，一年两年的人数不胜数，但是定投10年的呢？没几个人敢说吧，周期不一定会很短，也许很长，这个周期至少按五年计算。 如果你不打算持有一个股票10年，那就不必考虑甚至持有10分钟。 以上观点最好全部否认，反正也没几个人认同，哈哈。 还是读书书，不是学校里学的，也不能叫工具。以前我读不懂书，是因为太傻逼，很多的书滥竽充数，学校大部分也一文不值。读的不是书，是知识。你想知道的一切答案，在书中都可以找到。这个社会不缺聪明的人，而是缺“愚蠢的人”，大智若愚—也是我未来的目标。 展望未来终身成长，不断学习，时刻保持激情 虽然我是一个Android Developer，可我从未把自己定位为程序员，我可以干的事情很多，也能做远不止技术的范畴，未来我还能做什么？ ：Time Magician 送给看到这里的你的一句话不负现在，何惧未来","categories":[{"name":"思考","slug":"思考","permalink":"https://markfrank01.github.io/categories/思考/"}],"tags":[{"name":"自我思考","slug":"自我思考","permalink":"https://markfrank01.github.io/tags/自我思考/"}]},{"title":"公元前两天","slug":"公元前两天","date":"2018-12-30T15:07:40.000Z","updated":"2018-12-31T06:25:45.246Z","comments":true,"path":"2018/12/30/公元前两天/","link":"","permalink":"https://markfrank01.github.io/2018/12/30/公元前两天/","excerpt":"要想号令大海，必须先要得到三叉戟","text":"要想号令大海，必须先要得到三叉戟 我的2018本来想直接写年终总结的（其实也写好了），但是明天还有一天呐~所以~先简要说说吧 这一年以来最大的变化就是意识到了时间的重要性，Time is everything规划好自己的时间，价值远远超越了付出的金钱。我是非常认同知识付费，所以也在圈子里认识了很多朋友和大佬，从他们的分享中，使我不断发现我自身存在的问题并不断的调整。有的大佬在技术方面的分享使我受益匪浅，有的大佬在生活中的分享使我更加的清晰了自己该去方向和该走的路，非常感谢他们，没有他们的直接或间接的指导，我也许早就坚持不下去了。 明天再提交一下18年终篇和19年展望吧~","categories":[{"name":"思考","slug":"思考","permalink":"https://markfrank01.github.io/categories/思考/"}],"tags":[{"name":"自我思考","slug":"自我思考","permalink":"https://markfrank01.github.io/tags/自我思考/"}]},{"title":"公元前9天","slug":"公元前9天","date":"2018-12-23T10:42:31.000Z","updated":"2018-12-23T10:14:51.264Z","comments":true,"path":"2018/12/23/公元前9天/","link":"","permalink":"https://markfrank01.github.io/2018/12/23/公元前9天/","excerpt":"所有的光鲜靓丽都敌不过时间，并且一去不复返","text":"所有的光鲜靓丽都敌不过时间，并且一去不复返 成长的烦恼成长的过程中会有无数的烦恼，迈过之后，会进入不一样的地方。而迈不过终究只能原地打转。读书时代，我其实很早就思考了关于自己的职业发展及基础技能的培养学习。但当时的我没能摆脱自以为是的视野，以为世界就是我知道的样子，现在回想起来确实是井底之蛙。出来经历过外企，经历过大公司后，发现有的人真的可以有超乎同龄人的认知和视野。 在外企的那段时间里可以说是相当的压抑，所幸在完成工作之余还可以学到其他的东西。当时和一位特别聊的来的产品经常交流学习，他说想要往上走必须得把自己当作产品一样，不断打磨，不断提升自己的视野，而老板可不会告诉你这些。 看到今天大佬的分享我觉得这段话确实很适合形容有的外企：老板可不会和你说这么多，老板希望你永远低调，永远不要让外人知道，除了他没人知道你的本事，这样才可以用不高的代价一直压榨你，直到用尽你的能力，然后甩掉。 再回头看看，确实，当时过于的只关心技术和待遇，而忽略了提升自己的视野。确实，虽然我在不断的提升技术，但是当时太在意一点点的损失和一点点的利益，其实我所纠结来纠结去的现在看来一文不值。而视野受限终究走不长远。在成长时期需要把成长放在第一位，不要过于在意无关紧要的小事且需要珍惜时光。大部分人原地打转，浪费时间在一些娱乐上，只能是离时代越来越远。就像了不起的盖茨比中的一句经典：所有的光鲜靓丽都抵不过时间，并且一去不复返。","categories":[{"name":"思考","slug":"思考","permalink":"https://markfrank01.github.io/categories/思考/"}],"tags":[{"name":"自我思考","slug":"自我思考","permalink":"https://markfrank01.github.io/tags/自我思考/"}]},{"title":"公元前15天","slug":"公元前15天","date":"2018-12-16T10:42:31.000Z","updated":"2018-12-16T12:48:28.686Z","comments":true,"path":"2018/12/16/公元前15天/","link":"","permalink":"https://markfrank01.github.io/2018/12/16/公元前15天/","excerpt":"黄色的树林里分出两条路 我选择了人迹更少的一条 从此决定了我一生的道路","text":"黄色的树林里分出两条路 我选择了人迹更少的一条 从此决定了我一生的道路 前言纪年的开始为耶稣诞生之年，寓意为新生的开始。元年对我来说也是一种全新的开始，迷茫、思考、学习、尝试、反思，这些不过是成长道路上微小的但又不可或缺的路，2019对于我来说是一个全新的开始。不负当下，何惧未来 反思当我刚刚进入社会时，曾想不明白很多问题，其中最大的问题之一是关于金钱。为什么大多数人们为了生计奔波，而有的人却财富自由，难道是因为他们不够努力吗？还是因为他们甘愿如此？未来我像大多数人那样碌碌无为吗？ 对生活的恐惧和对自己的怀疑一度使我悲观，那一段时间让我痛苦，甚至对未来充满了悲观。但在那段时光里，我终于意识到了原因在于，生活中 金钱买不来幸福，短视 也不会带来金钱。一路以来，我的目光都太过短浅了，把自己困于曾经对自己的承诺之中，所以我在不停地追问，【我为什么想要变得更加富裕】。 你追问自己的问题将会决定你的人生轨迹我一直在追问自己 【为了变得富裕 我需要做些什么】。然后这只会让我更加的沉浸在犹豫之中。所以 我换了一个问题 我开始追问即使我失败了 我要如何继续热爱生活 怎么走下去。 我的朋友很多 我的好朋友不多 我想带着她们他们（LHM LM LHJ）一起完成梦想，我不知道我能不能变成我最想要的样子，但我知道如果我拼命改变自己的生活 并且意愿坚定，我就有可能成为梦想的自己。因为我意识到，今天我是谁并不重要，重要的是我想要成为谁，还有我愿意为此而付出的代价。借用别人的一句话： 我向你保证 当你有一天愿意不惜一切代价 你就会得到你想要的任何东西 如果你坚信这一点，人的潜力是无限的。你想要成为谁？你愿意为此付出什么代价？公元元年，我将全力奋斗 计划从多方面展开学习和实践 技术类 金融类 读书类 生活类 坚持把思考写成文字，呈现出来 行动将各个部分调整出合适的时间，使得自己可以更轻松的完成坚持的事情。","categories":[{"name":"思考","slug":"思考","permalink":"https://markfrank01.github.io/categories/思考/"}],"tags":[{"name":"自我思考","slug":"自我思考","permalink":"https://markfrank01.github.io/tags/自我思考/"}]}]}